# 动态连通性问题的Union-Find算法
## 背景
### 问题
- 问题的输入是一列整数对，其中每个整数都表示一个某种类型的对象，一对整数p和q可以被理解为“p和q是相连的”
- 假设相连是一种对等的关系，意味着
  - 自反性：p和q是相连的
  - 对称性：如果p和q是相连的，那么q和p也是相连的
  - 传递性：如果p和q是相连的，且q和r是相连的，那么p和r也是相连的
- 对等关系可以将对象分为多个等价类。在这里，当且仅当两个对象相连时它们才属于同一个等价类
### 目标
- 编写一个程序过滤掉序列中无意义的整数对（当两个整数都来自于同一个等价类）
- 即当程序从输入中读取了整数对p和q时，
  - 如果已知的所有整数对都不能说明p和q是相连的，那么则将这一对整数写入到输出中，
  - 如果已知的数据可以说明p和q是相连的，那么程序应该忽略这对整数，并继续处理下一对整数

## 分析
为了达到目标，需要设计一个数据结构来保存已知的所有整数对的足够多的信息，并用它们来判断一对新对象是否是相连的 

## union-find算法的API

|返回值|函数(参数)|说明|
|---|---|---|
|struct|NewUF(N int)|以整数标识（0到N-1）初始化N个触点|
|void|union(p,q int)|在p和q之间建立一条连接|
|int|find(p int)|p所在分量的标识符（0到N-1）|
|boolean|connected(p,q int)|如果p和q存在于同一个分两种则返回true|
|int|count()|连通分量的数量|

- 如果两个触点在不同的分量中，union操作会将两个分量归并
- find操作会返回给定触点所在的连通分量的标识符
- connected操作能判断两个触点是否存在于同一个分量之中
- count方法会返回所有连通分量的数量
- 一开始有N个分量，将两个分量归并的每次union操作都会使分量总数减一

## 实现
### 实现一
- 用一个以触点为索引的数组id[]作为基本数据结构来表示所有分量，使用分量中某个触点的名称作为分量的标识符
- 一开始有N个分量，每个触点都构成了一个只含有它自己的分量，因此可以将id[i]的值初始化为i，其中i在0到N-1之间
- 保证当且仅当id[p]=id[q]时p和q是连通的，即在同一个连通分量中的所有触点在id中的值相同，
- 这意味着connected(p,q)只需要判断id[p]==id[q]是否成立
- 在实现union(p,q)时，首先要检查它们是否已经存在于同一个连通分量中
  - 如果是，则直接返回即可，
  - 否则需要将p和q所在分量中所有触点的id值均设置为同一个值
  
## 复杂度分析
|版本|操作|时间复杂度|空间复杂度|
|---|---|---|---|
|实现一|find|O(1)|O(1)|
|实现一|union|O(n)|O(1)|
|实现一|connected|O(1)|O(1)|
|实现一|总复杂度|O(n^2)|O(n)|

## 应用
### 网络
### 变量名等价性
### 数学集合