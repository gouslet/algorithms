# 字符串查找
## 定义
给定一段长度为N的文本和一个长度为M的模式（pattern）字符串，在文本中找到一个和该模式相符的字符串
![](assets/字符串的查找.png)
### 特点
N >> M

## 衍生问题
- 找出文本中所有和该模式相符的子字符串
- 统计该模式在文本中的出现次数
- 找出上下文（和该模式相符的子字符串周围的文字）

## 应用
- 在文本编辑器中查找某个单词
- 在截获的通信内容中寻找某种重要的模式
## 暴力字符串查找算法
在文本中模式可能出现匹配的任何地方检查是否存在

### 实现一
用一个变量`i`跟踪文本，一个变量`j`跟踪模式。对于每个`i`，首先将`j`重置为`0`，并逐渐增大，直至找到了一个不匹配的字符或是模式结束
![](assets/暴力字符串查找.png)

见[violent_search.go:ViolentSearch1(txt, pattern string) int](violent_search.go#ViolentSearch1)

### 实现二
用一个变量`i`跟踪文本，一个变量`j`跟踪模式。首先将`j`重置`0`，对于每个`i`，逐渐增大`j`，直至找到了一个不匹配的字符或是模式结束。如果`i`和`j`位置指向的字符不匹配了，那么需要回退这两个变量的值：将j重新指向模式的开头（0），将`i`指向本次匹配开始位置的下一个位置

见[violent_search.go:ViolentSearch2(txt, pattern string) int](violent_search.go#ViolentSearch2)

## KMP字符串查找算法



## BM字符串查找算法
### 背景
当可以在文本字符串中回退时，如果可以从右至左地扫描模式字符串并将它和文本匹配，那么就能得到一种非常快的字符串查找方法

#### 例如
在查找子字符串BAABBAA时，如果匹配了第7个和第6个字符，但在第5个字符处匹配失败，那就可以马上将模式向右移动7个位置，并继续验查文本中的第14个字符

### 原理
#### 预处理
根据模式字符串构造一张每个字符在在模式中出现的最右位置的表格
#### 查找
查找算法会从右向左扫描模式字符串，并在匹配失败时通过跳跃将文本中的字符和它在模式字符串中出现的最右位置对齐

### 性能
完整的BoyerMoore算法预计算了模式字符串与自身的不匹配情况，并为最坏情况提供了线性级别的运行时间保证

#### 命题
在一般情况下，对于长度为N的文本和长度为M的模式字符串，使用了`Boyer-Moore`字符串查找算法通过启发式处理不匹配的字符需要$\sim N/M$次字符比较

## Rabin-Karp指纹字符串查找算法
它的基础是散列，它计算了模式字符串的散列值，并在文本中查找该散列值的匹配
### 基本思想
长度为M的字符串对应着一个R进制的M位数，为了用一张大小为Q的散列表来保存这种类型的键，需要一个能够将R进制的M位数转化为一个0到Q-1之间的int值散列函数

除留取余法是一个很好的选择：将该数除以Q并取余

在实际应用中会使用一个随机的素数Q，在不溢出的情况下选择一个尽可能大的值

#### 示例
![](assets/Rabin-Karp字符串查找算法的基本思想.png)

### 计算散列函数
对于5位的值，只需要使用int值即可完成所需的计算，但如果M是100或者1000怎么办呢？

此处使用Horner方法，对于这个数中的每一位数字，将散列值乘以R，加上这个数字，除以Q并取其余数

#### 示例

![](assets/Horner方法计算模式字符串的散列值.png)

### 关键思想
Rabin-Karp算法的基础是对于所有位置i，高效计算文本中i+1位置的字符串散列值

这可以由一个简单的数学公式得到：文本t中起始于i位置的含有M个字符的子字符串所对应的数即为
$$
    x[t] = t[i]R^{M-1} + t[i+1]R^{M-2} +...+ t[i+M-i]R^{0}
$$
假设已知$h(x_i) = x_i \ mod \ Q$，将模式字符串右移一位即等价于将$x_i$替换为
$$
  x_{i+1} = (x_i - t[i]R^{M-1})R + t[i + M] 
$$
即将它减去第一个数字的值，乘以R，再加上最后一个数字的值

这么做的结果是无论M是5、100还是1000，都可以在常数时间内高效地不断向右一格一格移动

#### 实现

#### 性能
- 使用蒙特卡洛算法的Rabin-Karp子字符串查找算法的运行时间是线性级别的且出错概率极小
- 使用拉斯维加斯算法的Rabin-Karp子字符串查找算法能够保证正确性，且性能极其接近线性级别
  
Rabin-Karp字符串查找算法也成为指纹字符串查找算法，因为它只用了极少量信息就表示了（可能非常大的）模式字符串，并在文本中寻找它的指纹（散列值）。

算法的高效性来源于指纹的高效计算和比较
## 总结
<table border="4">
  <caption>各种字符串查找算法的实现的成本总结</caption>
  <thead>
    <tr>
      <th rowspan = "2">算法</th>
      <th rowspan = "2">版本</th>
      <th colspan = "2" style="text-align:center" >操作次数</th>
      <th rowspan = "2" style="text-align:center" >在文本中回退</th>
      <th rowspan = "2" style="text-align:center" >正确性</th>
      <th rowspan = "2" style="text-align:center" >额外的空间需求</th>
    </tr>
    <tr>
      <th >最坏情况</th>
      <th >一般情况</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>暴力算法</td>
      <td style="text-align:center">-</td>
      <td>MN</td>
      <td>1.1N</td>
      <td>是</td>
      <td>是</td>
      <td>1</td>
    </tr>
    <tr>
      <td rowspan = "3">Knuth-Morris-Pratt算法</td>
      <td>完整的DFA</td>
      <td>2N</td>
      <td>1.1N</td>
      <td>否</td>
      <td>是</td>
      <td>MR</td>
    </tr>
    <tr>
      <td>仅构造不匹配的状态转换</td>
      <td>3N</td>
      <td>1.1N</td>
      <td>否</td>
      <td>是</td>
      <td>M</td>
    </tr>
    <tr>
      <td>完整版本</td>
      <td>3N</td>
      <td>N/M</td>
      <td>是</td>
      <td>是</td>
      <td>R</td>
    </tr>
    <tr>
      <td >Boyer-Moore算法</td>
      <td >启发式的查找不匹配的字符</td>
      <td>MN</td>
      <td>N/M</td>
      <td>是</td>
      <td>是</td>
      <td>R</td>
    </tr>
    <tr>
      <td rowspan = "2">Rabin-Karp算法</td>
      <td >拉斯维加斯算法</td>
      <td>7N*</td>
      <td>7N</td>
      <td>是</td>
      <td>是</td>
      <td>1</td>
    </tr>
    <tr>
      <td>蒙特卡洛算法</td>
      <td>7N</td>
      <td>7N</td>
      <td>否</td>
      <td>是*</td>
      <td>1</td>
    </tr>

  </tbody>
  <tfoot>
    <tr>
        <td colspan = "7">* 概率保证，需要使用均匀和独立的散列函数</td>
    </tr>
  </tfoot>
</table>