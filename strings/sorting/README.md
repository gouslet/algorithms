# 字符串排序算法
许多排序应用，决定顺序的键都是字符串，利用字符串的特殊性质，可以得到一些比通用排序算法效率更高的排序算法
## 键索引计数法
一种适用于小整数键的简单排序算法，同时也是后序字符串排序算法的基础

### 用例
老师在统计学生的分数时可能会遇到如下数据处理问题。学生被分为若干组，标号1、2、3等。在某些情况下，希望将全班同学按组分类。因为组的编号是较小的整数，使用键索引计数法来排序是很合适的，见下图

![](assets/适用于键索引计数法的典型情况.png)

假设数组`a[]`中的每个元素都保存了一个名字和一个组号，其中组号在`0~R-1`之间,，代码`a[i].key()`会返回指定学生的组号

这种方法有四个步骤
### 频率统计
第一步是使用`int`数组`count[]`统计每个键出现的频率。
![](assets/计算频率.png)

对于数组中的每个元素，都使用它的键访问`count[]`中的相应元素并将其加`1`
### 将频率转换为索引
接下来，使用count[]来计算每个键在排序结果中的起始索引的位置

![](assets/将频率转换为起始索引.png)

一般来说，任意给定的键的起始索引均为所有较小的键所对应的出现频率之和

对于每个键值`r`，小于r+1的键的频率之和为小于r的键的频率之和加上count[r]
### 数据分类
在将`count[]`数组转换为一张索引表后，将所有元素（学生）移动到一个辅助数组`aux[]`中以进行排序

![](assets/将数据分类.png)

每个元素在`aux[]`中的位置由它的键（组别）对应的`count[]`值决定，在移动之后将`count[]`中对应的元素的值加`1`，以保证`count[r]`总是下一个键为r的元素在`aux[]`中的索引位置

这个过程只需遍历一遍数据即可产生排序结果

这种排序方式具有稳定型，键相同的元素在排序后会被聚集到一起，但相对顺序没有发生变化
### 回写
因为在将元素移动到辅助数组的过程中完成了排序，所以最后一步是将排序的结果复制回原数组中

![](assets/键索引计数法（分类阶段）.png)

## 低位优先（LSD）的字符串排序
从右到左检查键中的字符，最适合于键的长度都相同的字符串排序应用

如果字符串的长度均为W，那就从右向左以每个位置的字符作为键，用索引计数法将字符串排序W遍

![](assets/低位优先排序.png)
### 应用
- 老式的卡片打孔排序机
- 扑克牌排序
  将所有牌（按大小）分成13堆，按顺序从13堆牌中抽取同样花色的扑克牌，最后将13堆牌变为4堆（按花色）
  分牌的过程是稳定的，因此花色中的牌也是有序的

## 高位优先（MSD）的字符串排序
从左到右检查键中的字符，首先查看的是最高位的字符。

不一定需要检查所有的输入就可以完成排序
## 三向字符串快速排序
## 字符串排序算法的选择