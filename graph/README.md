# 无向图
- 图是一组顶点和一组能够将两个顶点相连的边组成的
- 无向图中，边(edge)仅仅是两个顶点(vertex)之间的连接
- 使用0-V-1来表示一张含有V个顶点的图中的各个顶点，以便于使用数组来编写高效访问各个顶点中信息的代码
- 用v-w的记法来表示连接v和w的边，w-v是这条边的另一种表示方法
  
# 表示无向图的数据类型
用以表示图的数据结构需要符合以下两种要求
- 它必须为可能在应用中碰到的各种类型的图留出足够的空间
- Graph的实例方法的实现一定要快——它们是开发和处理图的各种用例的基础

此处采用邻接表数组来表示图结构——使用一个以顶点为索引的列表数组，将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中
```go
type Bag []int

type Graph struct {
	v int // 顶点数目
	e int // 边的数目

	adj []Bag // 	邻接表数组
}
```
这种实现的性能特点如下：
- 使用的空间和V+E成正比
- 添加一条边所需的时间为常数
- 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数）
- 每条边均会出现两次，即当存在一条边连接v与w的同时，w会出现在v的链表中，v也会出现在w的链表中

# 图处理算法的API
为了将图的表示和实现分离开来，将会为每个任务创建一个相应的类，用例可以创建相应的对象来完成任务

# 深度优先搜索
递归遍历图的所有顶点，在访问其中一个顶点时：
- 将它标记为已访问
- 递归地访问它没有标记过的邻居节点

如果图是连通的，每个邻接表中的元素都会被检查到

# 单点路径问题
- 构造函数接受一个起点s作为参数，计算s到与s连通的各个顶点之间的路径。
- 在为起点s创建了Paths对象之后可以使用HasPathTo(v)来判断是否存在到节点v的路径
- 调用PathTo(v)方法可以获得从s到其连通的顶点v之间的路径(用顶点数组表示)
  
# 广度优先搜索
- 按照与起点的距离递增的顺序来遍历所有顶点
- 用一个队列来保存所有已被标记过但其邻接表还没有被检查过的顶点
- 先将起点加入队列，然后重复以下步骤直到队列为空
  - 取队列中的下一个顶点v并标记它
  - 将与v相邻的所有未被标记过的顶点加入队列

# 单点最短路径
给定一幅图和一个起点s，回答“从s到给定目的点v是否存在一条路径？如果有，找出其中最短的那条（所含边的数量最少）”等问题

# 有向图
有向图中边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的

# 表示有向图的数据类型
使用邻接表来表示有向图，其中边v->w表示为顶点v所对应的邻接链表中包含一个w顶点
```go
type Digtaph struct {
	v int // 顶点数目
	e int // 边的数目

	adj []Bag // 	邻接表数组
}
```

# 有向无环图与拓扑排序
## 有向图中的环检测
- 基于深度优先搜索，因为由系统维护的递归调用的栈表示的正是“当前”正在遍历的有向路径
- 一旦找到一条边v->w且w已经存在于栈中，则找到了一个环，因为栈表示的是一条由w到v的有向路径，而v->w则正好令其成为一个环
## 顶点的深度优先次序与拓扑排序
深度优先搜索中遍历图数据结构时主要有三种访问次序：
- 前序：在递归调用之前将顶点加入队列
- 后序：在递归调用之后将顶点加入队列
- 逆后序：在递归调用之后将顶点加入栈
一幅有向无环图的拓扑排序即为所有顶点的逆后序排列

# 符号图
输入格式如下：
- 顶点名为字符串
- 用指定的分隔符来隔开顶点名（允许顶点名中有空格）
- 每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点
- 顶点总数V和边的总数E都是隐式定义的
 
## 用符号作为顶点名的图的API 
```go
	Cotains(key string) bool	// key是一个顶点吗？
	Index(key string) int	// key的索引
	Name(v int) string	// 索引v的顶点名
	G() *Graph	//隐藏的Graph对象
```

# 最短路径
## 最短路径的性质
- 路径是有向的
- 权重不一定等于距离
- 并不是所有顶点都是可达的
- 负权重会使问题更复杂
- 最短路径并不一定是唯一的
- 可能存在平行边和自环
## 单源最短路径问题
给定一个图$G(V,E)$，希望找到从给定源节点$s \in V$到每个节点$v \in V$的最短路径

单源最短路径问题的解可以用来解决以下几个变体问题：
- **单目的地最短路径问题**：找到从每个结点v到给定目的地结点t的最短路径
  - 将图的每条边的方向翻转过来即可转化为单源最短路径问题
- **单结点对最短路径问题**：找到从给定结点u到给定结点v的最短路径
  - 在该问题的所有已知算法中，最坏情况下的渐近运行时间都和最好的单源最短路径算法的运行时间一样
- **所有结点对最短路径问题**：对于每对结点u和v，找到从结点u到结点v的最短路径
  - 不需要针对每个结点运行一遍单源最短路径算法