# 无向图
- 图是一组顶点和一组能够将两个顶点相连的边组成的
- 无向图中，边(edge)仅仅是两个顶点(vertex)之间的连接
- 使用0-V-1来表示一张含有V个顶点的图中的各个顶点，以便于使用数组来编写高效访问各个顶点中信息的代码
- 用v-w的记法来表示连接v和w的边，w-v是这条边的另一种表示方法
  
# 表示无向图的数据类型
用以表示图的数据结构需要符合以下两种要求
- 它必须为可能在应用中碰到的各种类型的图留出足够的空间
- Graph的实例方法的实现一定要快——它们是开发和处理图的各种用例的基础

此处采用邻接表数组来表示图结构——使用一个以顶点为索引的列表数组，将每个顶点的所有相邻顶点都保存在该顶点对应的元素所指向的一张链表中
```go
type Bag []int

type Graph struct {
	v int // 顶点数目
	e int // 边的数目

	adj []Bag // 	邻接表数组
}
```
这种实现的性能特点如下：
- 使用的空间和V+E成正比
- 添加一条边所需的时间为常数
- 遍历顶点v的所有相邻顶点所需的时间和v的度数成正比（处理每个相邻顶点所需的时间为常数）
- 每条边均会出现两次，即当存在一条边连接v与w的同时，w会出现在v的链表中，v也会出现在w的链表中

# 图处理算法的API
为了将图的表示和实现分离开来，将会为每个任务创建一个相应的类，用例可以创建相应的对象来完成任务

# 深度优先搜索
递归遍历图的所有顶点，在访问其中一个顶点时：
- 将它标记为已访问
- 递归地访问它没有标记过的邻居节点

如果图是连通的，每个邻接表中的元素都会被检查到

# 单点路径问题
- 构造函数接受一个起点s作为参数，计算s到与s连通的各个顶点之间的路径。
- 在为起点s创建了Paths对象之后可以使用HasPathTo(v)来判断是否存在到节点v的路径
- 调用PathTo(v)方法可以获得从s到其连通的顶点v之间的路径(用顶点数组表示)
  
# 广度优先搜索
- 按照与起点的距离递增的顺序来遍历所有顶点
- 用一个队列来保存所有已被标记过但其邻接表还没有被检查过的顶点
- 先将起点加入队列，然后重复以下步骤直到队列为空
  - 取队列中的下一个顶点v并标记它
  - 将与v相邻的所有未被标记过的顶点加入队列

# 单点最短路径
给定一幅图和一个起点s，回答“从s到给定目的点v是否存在一条路径？如果有，找出其中最短的那条（所含边的数量最少）”等问题

# 有向图
有向图中边是单向的：每条边所连接的两个顶点都是一个有序对，它们的邻接性是单向的

# 表示无向图的数据类型
使用邻接表来表示有向图，其中边v->w表示为顶点v所对应的邻接链表中包含一个w顶点
```go
type Digtaph struct {
	v int // 顶点数目
	e int // 边的数目

	adj []Bag // 	邻接表数组
}
```

# 符号图

- 顶点名为字符串
- 用指定的分隔符来隔开顶点名（允许顶点名中有空格）
- 每一行都表示一组边的集合，每一条边都连接着这一行的第一个名称表示的顶点和其他名称所表示的顶点
- 顶点总数V和边的总数E都是隐式定义的
 
## 用符号作为顶点名的图的API 
```go
	Cotains(key string) bool	// key是一个顶点吗？
	Index(key string) int	// key的索引
	Name(v int) string	// 索引v的顶点名
	G() *Graph	//隐藏的Graph对象
```

