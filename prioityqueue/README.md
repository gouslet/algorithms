# 优先队列

# 特点
- 要处理的元素可以不要求同时全部有序
- 支持两种基本操作
  - 删除最大元素
  - 插入元素
# 应用场景
- 模拟系统
  - 事件的键为发生的时间，系统需要按照时间顺序处理所有事件
- 任务调度
  - 键值对应的优先级决定了应该首先执行哪些任务
- 数值计算
  - 键值代表计算错误，需要按照指定的顺序来修正
# API
```go
type MaxPQ interface {
	Insert(k interface{}) // 向优先队列中插入一个元素
	Max() interface{}     // 返回最大元素
	DelMax() *interface{} // 删除并返回最大元素
	IsEmpty() bool        // 返回队列是否为空
	Size() int            // 返回优先队列中的元素个数
}
```
# 实现
## 无序数组实现
## 有序数组实现
## 链表表示
## 基于堆的实现
### 原理
- 二叉堆可以很好地实现优先队列的基本操作
- 当一棵二叉树的每个结点都大于（小于）或等于它的两个子节点时，它被称为堆有序的，根结点是堆有序的二叉树中的最大（小）结点
- 完全二叉树可以用数组来表示，二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不适用数组的第一个元素），见下图![avatar](/PrioityQueue/img/二叉堆的结构.png)
- 在一个二叉堆中位置k的结点的父结点的位置为$\llcorner k/2 \lrcorner$，而它的两个结点的位置则为$2k$和$2k+1$，这样在不使用指针的情况下也可以通过计算数组的索引在树中上下移动：从a[k]向上移动一层就令$k$等于$k/2$，向下一层则令$k$等于$2k$或$2k+1$
- 利用二叉堆可以实现对数级别的插入元素和删除最大（小）元素的操作
### 方案
- 用长度为N+1的数组pq来表示一个大小为N的堆，堆元素放在pq[1]至pq[N]中，
- 堆的操作首先会进行一些简单的改动，打破堆的状态，然后再遍历堆并按照要求将堆的状态恢复，后面这个过程称为堆的有序化(reheapifying)
- 在有序化的过程中会遇到两种情况，
  - 当某个结点的优先级上升（或是在堆底加入一个新的元素）时，需要由下至上恢复堆的顺序
  - 当某个结点的优先级下降（例如，将根结点替换为一个较小的元素）时，需要由上至下恢复堆的顺序

# 索引优先队列
## 需求
访问已经进入优先队列的元素 
